use extend::ext;
use std::hash::Hash;

// TODO: it might make sense to make a utility-trait like `trait Has: TypeWitness { type Bound: ?Sized }`
//       which is PURELY implemented by "witness" types such that they somehow describe the bounds
//       that they represent. E.g. maybe `impl<T: ?Sized> Has for CloneWit<T> { type Bound = dyn Clone }`
//       or some other type that implements that trait bound.
//       This way, we can e.g. define a "constraint" associated type e.g. `trait Foo { type Constraint: TypeWitness, ... }`
//       and then in _generic_ functions that use this type we can more fluently specify a generic constrain,
//       e.g. `fn foo<T: Foo<Constraint: Has<Bound: Clone>>>(val: T) { .. }` which reads SO MUCH NICER
//            but because of all the blanket-impls everywhere, you should easily be able to slot-in
//            simply just `CloneWit` or something equivalent into it...
// TODO: maybe RENAME type-witnesses into something like "Constraint" ?? because ultimately
//       that is what they represent... so that it coincides more cleanly with Haskell

/// All the traits implemented by [`std::marker::PhantomData`], and thus should be implemented
/// by all type-witnesses, except for [`Default`] which can only be there if a trait-bound is satisfied.
trait PhantomDataImpls = Hash + Eq + Ord + Copy; // + Default

/// TODO: maybe I can add some kind of associated type HList of all the TypeWitnesses???
///       that way you can "accumulate" type-witnesses in order to more ergonomically deal with
///       type-witnesses???
/// TODO: then I could make a macro that would provide default implementations for `*Instance` traits
///       to inspect the HList and if ONE of the types there is a type-witness satisfying whatever,
///       then it works???? idk i'd have to think about it a little more....
/// TODO: Perhaps we can introduce a utility-trait called "Provider", such that instance-traits
///       are parametrized on `wit: W where W: Provider<FooWit>` ?? that way we can "combine" witnesses
///       together??
/// TODO: but for that, we might need a more convenient data-structure - like "heterogenous binary tree"
///       rather than the HList found in Frunk - in order to make "adding" trees easier. So a witness is
///       really just a "proof-tree" - the leafs are the individual "type-witnesses" while "Node"s would
///       be custom operations like `And<Proof, Proof>` which would itself become another proof
///       whose associated type `TypeWitness::ProofTree` would be the HTree of all the individual "leafs"
///       e.g. ```rust
///            impl TypeWitness for And<IsWit, And<CloneWit, EqWit>> {
///              ProofTree = Node<Leaf<IsWit>, Node<Leaf<CloneWit>, Leaf<EqWit>>
///            }
///            ```
///       but ofcourse that implementation should be auto-generated by a blanket implementation
///       and hopefully the type-level `Heterogenous Binary Tree` can even be BALANCED for more
///       efficient lookup (since this is what we want to do) or perhaps even
///       "Left-child right-sibling binary tree" if the need ever arises to deal with >2 children
///       per node???
/// TODO: if I somehow can manage to make the "proof extractor"-trait dyn-compatible, then it might
///       even be possible to write something like this `struct MyBar<T>(T, DynWit<dyn Provider<FooWit>>)`
///       where `DynWit<T>(PhantomData<T>)` is a ZST with smart constructor `fn new<T: Provider<??>>() -> DynWit<dyn Provider<FooWit>>`
///       such that `DynWit<dyn Provider<FooWit>>` auto-implements `Provider<FooWit>`
///       that way you can "collapse" _all_ proof-trees that contain a certain proof into one existential type
///       so e.g. you could feed `IsWit`, `And<.., IsWit>`, `And<.., And<.., IsWit>>` all into something that expects DynWit<dyn Provider<IsWit>>
///       ALL without having to introduce extra type-parameters to hold the "type" of provider of that particular proof...??
pub trait TypeWitness: PhantomDataImpls {}

#[ext(pub, name = TypeWitnessExt)]
impl<W: TypeWitness> W {
    #[inline]
    fn with<T>(self, value: T) -> With<T, W>
    where
        W: Sized,
    {
        With::new(value, self)
    }
}

// TODO: right now, implementing traits on this is rather awkward, as the result is "wrapped"
//       e.g. a naiive implementation of `impl<T> Clone for With<T, CloneWit>` would be
//            `&With<T, CloneWit> -> With<T, CloneWit>` where we __really__ want something like
//            `&With<T, CloneWit> -> T` or more generally I want `With<T, CloneWit>` to be a RECEIVER
//            for type `T` - but only sometimes?? idk...
/// A value of type [`T`] along with witness [`W`] of some type-constraints it meets.
pub struct With<T: ?Sized, W: TypeWitness> {
    witness: W,
    value: T,
}

mod impls {
    use crate::typelevel::typewitness::{TypeWitness, With};

    impl<T: ?Sized, W: TypeWitness> With<T, W> {
        #[inline]
        pub const fn new(value: T, witness: W) -> Self
        where
            T: Sized,
        {
            Self { witness, value }
        }

        #[inline]
        pub const fn value(&self) -> &T {
            &self.value
        }

        #[inline]
        pub const fn value_mut(&mut self) -> &mut T {
            &mut self.value
        }

        #[inline]
        pub fn into_value(self) -> T
        where
            T: Sized,
        {
            self.value
        }

        #[allow(clippy::clone_on_copy)]
        #[inline]
        pub fn witness(&self) -> W {
            self.witness.clone()
        }

        #[inline]
        pub fn tuple(&self) -> (&T, W) {
            (&self.value, self.witness())
        }

        #[inline]
        pub fn tuple_mut(&mut self) -> (&mut T, W) {
            let witness = self.witness();
            (&mut self.value, witness)
        }

        #[inline]
        pub fn into_tuple(self) -> (T, W)
        where
            T: Sized,
        {
            (self.value, self.witness)
        }

        #[allow(clippy::clone_on_copy)]
        #[inline]
        pub fn transpose_ref(&self) -> With<&T, W> {
            With {
                witness: self.witness.clone(),
                value: &self.value,
            }
        }

        #[allow(clippy::clone_on_copy)]
        #[inline]
        pub fn transpose_mut(&mut self) -> With<&mut T, W> {
            With {
                witness: self.witness.clone(),
                value: &mut self.value,
            }
        }
    }
}
