use misc::typelevel::clone::CloneWit;

/// The type-constructor for the `Vec<_>` data-type.
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]
pub struct VecConstructor;

/// A newtype-wrapper for [`Vec`] which represents those `Vec<T>` where `T: Clone`.
pub struct CloneVec<T>(pub Vec<T>, pub CloneWit<T>);

/// The type-constructor for the `CloneVec<_>` data-type.
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]
pub struct CloneVecConstructor;

mod vec_impls {
    use crate::family_pattern::data::vec::VecConstructor;
    use crate::family_pattern::typeclasses::bind::BindMut;
    use crate::family_pattern::typeclasses::functor::FunctorMut;
    use crate::family_pattern::typeclasses::monoid::Monoid;
    use crate::family_pattern::typeclasses::pure::Pure;
    use crate::family_pattern::typeclasses::semigroup::Semigroup;
    use crate::family_pattern::{ConstructableTy1, TyConstructor1};

    impl<T> ConstructableTy1 for Vec<T> {
        type GenericParameter1 = T;
        type Constructor = VecConstructor;
    }

    impl TyConstructor1 for VecConstructor {
        type TC1<T> = Vec<T>;
    }

    impl<T> Semigroup for Vec<T> {
        #[inline]
        fn scombine(mut self, mut other: Self) -> Self {
            self.append(&mut other);
            self
        }
    }

    impl<T> Monoid for Vec<T> {
        #[inline]
        fn mempty() -> Self {
            vec![]
        }
    }

    impl FunctorMut for VecConstructor {
        #[inline]
        fn fmap_mut<A, B, F: FnMut(A) -> B>(fa: Vec<A>, f: F) -> Vec<B> {
            fa.into_iter().map(f).collect()
        }
    }

    impl Pure for VecConstructor {
        #[inline]
        fn pure<A>(a: A) -> Vec<A> {
            vec![a]
        }
    }

    impl BindMut for VecConstructor {
        #[inline]
        fn bind_mut<A, B, F: FnMut(A) -> Vec<B>>(ta: Vec<A>, f: F) -> Vec<B> {
            ta.into_iter().flat_map(f).collect()
        }
    }
}

mod clone_vec_impls {
    use crate::family_pattern::data::vec::{CloneVec, CloneVecConstructor};
    use crate::family_pattern::typeclasses::monoid::Monoid;
    use crate::family_pattern::typeclasses::pure::Pure;
    use crate::family_pattern::typeclasses::semigroup::Semigroup;
    use crate::family_pattern::{syntax::*, ConstructableTy1, TyConstructor1};
    use misc::typelevel::clone::{is_clone, CloneInstance as _};

    impl<T> Clone for CloneVec<T> {
        #[inline]
        fn clone(&self) -> Self {
            // TODO: this may be potentially a SUUUPER inefficient way to do this, if a better way
            //       is found to "lower" type-witnesses into trait bounds then it should be taken 100%
            let mut cloned = Vec::with_capacity(self.0.len());
            for i in &self.0 {
                cloned.push(i.clone_with(&self.1));
            }
            Self(cloned, self.1)
        }
    }

    impl<T> ConstructableTy1 for CloneVec<T> {
        type GenericParameter1 = T;
        type Constructor = CloneVecConstructor;
    }

    impl TyConstructor1 for CloneVecConstructor {
        type TC1<T> = CloneVec<T>;
    }

    // TODO: this simple "delegation" implementations should deffo be generated by Macro of some kind
    impl<T> Semigroup for CloneVec<T> {
        #[inline]
        fn scombine(self, other: Self) -> Self {
            Self(self.0.scombine(other.0), self.1)
        }
    }

    impl<T: Clone> Monoid for CloneVec<T> {
        // TODO: I wonder if the type-witness should actually be supplied as an argument??
        //       e.g. ```rust
        //            trait Monoid: Semigroup {
        //              type Constraint: TypeWitness;
        //              fn mempty<C: Provider<Self::Constraint>>(c: C) -> Self;
        //            }
        //            ```
        //       because RN this implementation ain't very useful....
        #[inline]
        fn mempty() -> Self {
            Self(Vec::mempty(), is_clone())
        }
    }

    // TODO: CAN'T EVEN DO THIS because `fa.1` is of type `CloneWit<A>` but I need `CloneWit<B>`
    //       I need __SOME__ way of specifying that `B: Clone`, its really annoying that I can't do this...
    // TODO: maybe the solution is to introduce something like "WeakFunctor"??
    //       where it has `type Target<T> = Vec<T>` and
    //       `fn fmap<A, B, F: Fn(A) -> B>(fa: CloneVec<A>, f: F) -> Vec<B>` ??
    //       I just don't know any other way to do this...
    // impl FunctorMut for CloneVecConstructor {
    //     #[inline]
    //     fn fmap_mut<A, B, F: FnMut(A) -> B>(fa: CloneVec<A>, f: F) -> CloneVec<B> {
    //         CloneVec(fa.0.fmap_mut(f), fa.1)
    //     }
    // }

    // TODO: same problem as above...

    // impl Pure for VecConstructor {
    //     #[inline]
    //     fn pure<A>(a: A) -> Vec<A> {
    //         vec![a]
    //     }
    // }

    // impl BindMut for VecConstructor {
    //     #[inline]
    //     fn bind_mut<A, B, F: FnMut(A) -> Vec<B>>(ta: Vec<A>, f: F) -> Vec<B> {
    //         ta.into_iter().flat_map(f).collect()
    //     }
    // }

    // TODO: and this is where I WOULD have been able to implement "applicative" were it not
    //       for the stupid type-constraint issue as above..................................
}
